#### הסבר כללי
**קלט**: סדרה של `n` מספרים $\langle a_1, a_2, ..., a_n \rangle$
**פלט**: תמורה (שינוי סדר) $\langle a_1^`, a_2^`, ..., a_n^` \rangle$  של סדרת הקלט המקיימת $a_1^` \le a_2^` \le ... \le a_n^`$  
**אופן העבודה**: 

**סיבוכיות זמן**: $O(n^2)$ 

```pseudocode
for j <- 2 to length[A]
	do key <- A[j]
		# Insert A[j] into the sorted sequence A[1 ... j-1]
		i <- j-1
		while i>0 and A[i]>key
			do A[i+1] <- A[i]
				i <- i-1
		A[i+1] <- key
```

```python
def insertion_sort(a):
    for j in range(1, len(a)):
        key = a[j]
        i = j - 1
        while i >= 0 and a[i] > key:
            a[i + 1] = a[i]
            i -= 1
        a[i + 1] = key
    return a
```

האלגוריתם יעיל למיון מספר קטן של פריטים.

#### שמורת הלולאה
1. **אתחול**: תחילה נראה ששמורת הלולאה נכונה לפני האיטרציה הראשונה, כאשר `j=2`. האיבר היחיד בתת-מערך `A[1, ..., j-1]` הוא `A[1]`. תת-מערך זה ממוין באופן טריוויאלי. על כן מתקיימת שמורת הלולאה לפני הכניסה לאיטרציה הראשונה.
2. **תחזוקה**: גוף הלולאה ה-for החיצונית מזיז את `A[j-3]`, `A[j-2]`, `A[j-1]`, וכן הלאה, מקום אחד ימינה בכל פעם, עד ש-`A[j]` מגיע למקום הנכון, ואז מוכנס הערך של `A[j]`.
3. **סיום**: לולאת ה-for החיצונית מסתיימת כאשר j, כדול מ-n, כלומר `j = n+1`. נציב `n+1` במקום `j` בניסוח שמורת הלולאה ונקבל שהמערך `A[1, ..., n]` מורכב מאותם איברים שהיו ב-`A[1, ..., n]` בתחילת התהליך, כאשר הם ערוכים לפי סדר המיון הרצוי. מכיוון שתת-מערך `A[1, ..., n]` הוא כל המערך - אזי כל המערך ממוין והאלגוריתם נכון.

